Отличный вопрос. Предлагаю привести фильтры к «каскадной» логике и единой модели данных. Кратко, что делаем.

Как должно работать
	1.	Источник (INNERDB | NAUSYS) — переключатель вверху модалки.
Он влияет только на то, откуда берутся справочники и какие поля будут в запросе (но UI одинаковый).
	2.	Каскад: Countries → Regions → Locations
	•	Countries (мульти-выбор).
	•	Regions (мульти-выбор) показываются только для уже выбранных стран.
	•	Locations (мульти-выбор) показываются только для выбранных регионов (если регионы пусты — для выбранных стран).
	•	При снятии страны — автоматически снимаем её регионы и локации из выбора.
	•	При снятии региона — очищаем его локации из выбора.
	3.	Взаимная подсветка/связность
	•	В выпадающих списках у регионов и локаций показываем «breadcrumb» (HR › Split region › ACI Marina Cres).
	•	В каждой «чипсе» (выбранный элемент) показываем коротко: HR • Split, HR • Trogir, чтобы визуально ясно, что связано с чем.
	4.	Пустые выборы = нет ограничений
	•	Пустые Countries ⇒ Regions/Locations пустые и disabled (до выбора стран).
	•	Пустые Regions при выбранных Countries ⇒ Locations строятся по Countries.
	•	Если ничего не выбранo в Countries/Regions/Locations — геофильтр не применяется.

Модель данных (в фильтре)

Храним всегда ID из нашей БД (а не текст):
	•	countryIds: string[]  (наши Country.id)
	•	regionIds: string[]   (наши Region.id)
	•	locationIds: string[] (наши Location.id)

Для NAUSYS-кандидатов при сохранении цены мы уже можем вычислять countryCode через locationId → region → country, но для фильтра это не критично: фильтрация делается join’ами по нашим таблицам (Country/Region/Location).

Загрузка справочников
	•	При открытии модалки:
	•	грузим Countries (все)
	•	Regions и Locations лениво:
	•	Regions — только по выбранным countryIds
	•	Locations — по выбранным regionIds (если их нет — по countryIds)
	•	Кэшируем результаты в состояние модалки, чтобы не дергать бэкенд при каждом клике.

Применение фильтров (бэкенд)
	1.	В эндпоинте GET /scrape/competitors-prices (и превью):
	•	Когда пришли countryIds/regionIds/locationIds, строим условие-«ИЛИ» по географии:

(locationId ∈ chosenLocations)
OR (regionId ∈ chosenRegions)
OR (countryId ∈ chosenCountries)


	•	Если задан низший уровень (locations), он самодостаточен; регионы/страны добавляют «шире» (объединение).
	•	Для NAUSYS записей, где есть только marina (locationId в виде строки), делаем join к Location → Region → Country (или мапу в памяти) при выборке/агрегации.

	2.	Для INNERDB аналогично: у нас у лодок/локаций уже есть связи; фильтрация join’ами.

UI-поведение и UX-мелочи
	•	Под строками выбора показываем счетчики доступных элементов (например, Regions (27) для выбранных стран).
	•	Если выбор в регионах перекрывает все локации, можно показывать hint «Все локации в выбранных регионах будут учтены».
	•	«Reset filters» обнуляет все три массива.
	•	«Test filters» должен пробрасывать ровно ту же геологику (OR, каскад) в превью.

Алгоритм вычисления страны для NAUSYS-кандидата (для консистентности)
	•	При сборе кандидатов:
	1.	берем locationFromId (или meta.locationId);
	2.	через мапу locationId -> regionId -> countryId вытаскиваем нашу Country;
	3.	сохраняем в CompetitorPrice: countryId (FK на нашу Country) и countryCode (ISO-2) — удобно для быстрых агрегатов и фронта.
	•	Если location не мапится (редкий кейс) — сохраняем без countryId/countryCode; такой кандидат не пройдет геофильтр по стране, но пройдет при пустых геофильтрах.

Edge cases
	•	Выбрана страна, но ни один регион/локация в нашей базе не привязан — показываем подсказку в модалке «Для HR нет локаций/регионов. Обновите справочники.»
	•	При переключении источника (INNERDB↔NAUSYS) сохраняем последние выборы отдельно для каждого источника (две независимые «маски» фильтра), чтобы пользователю было удобно тестировать.

Что сделать по коду (минимальный план)
	1.	Бэкенд
	•	Эндпоинты справочников:
	•	GET /catalog/countries
	•	GET /catalog/regions?countryIds=...
	•	GET /catalog/locations?countryIds=...&regionIds=...
	•	В scraper.service при сохранении NAUSYS кандидатов пробросить countryId/countryCode через мапу (locationId -> region -> country).
	•	В выборках конкурентных цен учесть геофильтр OR по трём уровням.
	2.	Фронтенд
	•	В модалке Competitor filters:
	•	хранить {countryIds, regionIds, locationIds} отдельно для каждого источника;
	•	грузить регионы и локации лениво от выбранных уровней;
	•	каскадно очищать нижние уровни при снятии верхних;
	•	«Test filters» и «Apply & Save» отправляют те же поля.
	3.	Данные
	•	Убедиться, что таблицы Country/Region/Location заполнены корректно (у Region есть countryId, у Location есть regionId).
	•	Для NAUSYS Location.nausysId и Region.nausysId заполнены — это ускорит маппинг.

⸻

Если хочешь, могу набросать точные сигнатуры DTO (frontend + backend) и псевдо-код join’а для фильтра в сервисе выборки — скажи, какой слой начнём править первым.